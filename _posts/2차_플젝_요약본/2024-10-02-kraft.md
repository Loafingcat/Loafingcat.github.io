---
title: Kraft mode
date: 2024-10-25 16:30:00 +0900
categories: [Kafka]
tags: [kafka]     # TAG names should always be lowercase
authors: [LoafingCat]
---


kraft 모드를 사용해서 kafka 클러스터를 구성했었는데 어째서 주키퍼를 사용하지 않았는지에 대해서 DM으로 중복적으로 질문이 들어와서 좀 더 생각해보게 됐습니다.

기존에는 향후 kafka에서 더이상 주키퍼를 지원하지 않는다는 것과(4.x 버전 예정) 주키퍼를 사용하는 것보다 karft가 구축하는데 있어 난이도도 더 낮기 때문이었는데, 

이 정도는 충분한 설명이 되지 않는거 같아서 주키퍼가 아닌 kraft를 쓸만한 이유를 찾아보기로 했습니다.


## KRaft의 등장과 배경

KRaft (Kafka Raft)는 아파치 카프카(Apache Kafka)의 분산 시스템을 관리하기 위해 도입된 새로운 메커니즘입니다.(2.8버전부터)

이전까지 카프카는 아파치 주키퍼(Apache ZooKeeper)를 사용하여 클러스터 메타데이터의 관리와 조정을 담당했습니다.

그러나 주키퍼의 의존성은 카프카의 확장성과 유지보수에 여러 제약을 가져왔고,

이를 해결하기 위해 카프카 자체 내에서 분산 시스템의 상태를 관리하는 방식을 도입하기로 결정하였습니다.



주키퍼 사용 시 이슈가 되는 부분들에 대해 조금 자세히 살펴보겠습니다.

### 1. 성능적인 부분

주키퍼를 사용하면서 복잡한 아키텍처, 주키퍼 클러스터를 구성하기 위한 추가적인 서버 리소스로 인한 운영 비용 증가 등등 여러 가지 불편하거나 제한적인 상황이 있었겠지만,  

성능적인 이슈 때문에 새로운 매커니즘을 도입하게 됐다고 생각합니다.

브로커는 모든 토픽과 파티션에 대한 메타데이터를 주키퍼에서 읽어야 하며, 메타데이터의 업데이터는 주키퍼에서 동기방식으로 일어나는 반면에 브로커에는 비동기방식으로 전달됩니다.

이 과정에서 메타데이터의 불일치가 발생 할수도 있으며, 컨트롤러 재시작 시 모든 메타데이터를 주키퍼로부터 읽어야 하는 것도 부담이 있습니다.

특히 토픽과 파티션이 많은 대규모 카프카 클러스터에서는 이러한 과정에 오랜 시간이 걸리는 등 병목현상이 발생할 수 있습니다.

### 2. 관리적인 부분

주키퍼와 카프카는 완전히 서로 다른 애플리케이션으로 서로 다른 구성 파일, 환경, 서비스 데몬을 가지고 있습니다.

결국 관리자는 동시에 서로 다른 두 개의 애플리케이션을 운영해야 합니다. 동시에 두 가지 애플리케이션을 운영한다는 것은 관리자에게 큰 부담이 됩니다.

예를 들어 주키퍼의 릴리스 노트 확인, 버전 업그레이드, 구성 파일 변경과 동시에 카프카의 또한 모든 구성요소를 바꿔줘야하기 때문입니다.

### 3. 모니터링

모든 서비스는 모니터링이 필수이며, 주키퍼와 카프카 둘 다 모니터링을 해야 합니다.

두 애플리케이션은 서로 다른 애플리케이션이므로, 모니터링을 적용하는 방법과 각 애플리케이션에서 보여주는 주요 메트릭도 다릅니다.

또한 모니터링에 필요한 필수 메트릭과 모니터링하는 방법까지 완전히 다릅니다.

그 외에도 각 애플리케이션에서 빈번하게 발생하는 이슈 또는 장애 상황에 개별적으로 대처해야 합니다.

두 애플리케이션 간 통신 장애가 발행한다면 메타데이터 불일치, 리더 선출 실패 등등의 복잡한 문제가 생기겠죠.



## KRaft의 주요 목적

KRaft의 주요 목적은 카프카의 구조를 단순화하고 확장성을 향상시키기 위함입니다.

앞에서 언급한 여러 불편한 부분들이 주키퍼를 제거함으로써 설치, 구성, 유지보수가 단순화될 뿐만 아니라 카프카의 성능과 안정성 역시 크게 향상됩니다.

KRaft를 카프카와 결합해서 운영 복잡성을 줄이고, 전반적인 신뢰성과 관리 용이성을 개선하는데 기여할 수 있습니다.

또한 더욱 강력하고 유연한 시스템으로 만들어 대규모 데이터 처리 환경에서의 효율성을 높일 수 있습니다.



## 주키퍼 모드 vs KRaft 모드

이제부터는 카프카 클러스터를 주키퍼 모드와 KRaft 모드에 대한 차이점을 살펴보겠습니다.

먼저 주키퍼 모드에 대해 살펴보겠습니다.

### 1. 주키퍼 모드

![alt text](79bf6fe27f866c77c6469acb40111ea0c513f37b17d68716d39e516971ed7319.png)

주키퍼 모드는 주키퍼 앙상블과 카프카 클러스터가 존재하며, 카프카 클러스터 중 하나의 브로커가 컨트롤러 역할을 하게 됩니다.

컨트롤러는 파티션의 리더를 선출하는 역할을 하며, 리더 선출 정보를 브로커에게 전파하고 주키퍼에 리더 정보를 기록하는 역할을 합니다.

컨트롤러의 선출 작업은 주키퍼의 임시노드를 통해 이루어집니다.

임시노드에 가장 먼저 연결에 성공한 브로커가 컨트롤러가 되고, 다른 브로커들은 해당 임시노드에 이미 컨트롤러가 있다는 사실을 통해 카프카 클러스터 내 컨트롤러가 있다는 것을 인식하게 됩니다.

그러므로 한 번에 하나의 컨트롤러만 클러스터에 존재하게 됩니다.

### 2. KRaft 모드

![alt text](2af7ca0ef11ec9f4a101f0b425eaee72d79ddf4ab908ca0b0946a5118890ab3c.png)

그림과 같이 KRaft 모드에서는 주키퍼가 사라졌습니다.

KRaft 모드는 주키퍼와의 의존성을 제거하고, 카프카 단일 애플리케이션 내에서 메타데이터 관리 기능을 수행하는 독립적인 구조가 되는 것입니다.

주키퍼 모드에서 1개였던 컨트롤러가 3개로 늘어나고, 이들 중 하나의 컨트롤러가 액티브 컨트롤러이면서 리더 역할을 담당합니다.

리더 역할을 하는 컨트롤러가 write 하는 역할도 하게 됩니다.(컨트롤러는 홀수로 설정하는 것이 바람직함)

또한 주키퍼 노드에서는 메타 데이터 관리를 주키퍼가 했다면, 이제는 카프카 내부의 별도 토픽을 이용하여 메타 데이터를 관리합니다.

액티브인 컨트롤러가 장애 또는 종료되는 경우, 내부에서는 새로운 합의 알고리즘(KAFKA_CONTROLLER_QUORUM_VOTERS)을 통해 새로운 리더를 선출하게 됩니다.

리더를 선출하는 과정을 간략히 설명드리자면, 후보자들은 적합한 리더를 투표하게 되고 후보자 중 충분한 표를 얻으면, 해당 컨트롤러가 새로운 리더가 됩니다.

(왜 컨트롤러는 홀수로 설정해야하는지에 대한 내용은 다음에 다루도록 하겠습니다)



## KRaft의 성능

KRaft의 주요 성능 개선 중 하나는 파티션 리더 선출의 최적화입니다. 

컨트롤러의 주요 역할은 파티션의 리더를 선출하는 것입니다.

소수의 파티션에 대한 리더 선출 작업은 카프카 또는 카프카를 사용하는 클라이언트들에게 별다른 영향이 없을 수 있지만

대량의 파티션에 대한 리더 선출 작업은 다소 시간이 소요되며,

이러한 시간은 대량의 데이터 파이프라인의 역할을 하는 카프카와 클라이언트들에게 매우 크리티컬한 요소일 수 있습니다.

따라서 이러한 지연 시간을 방지하고자 주키퍼 모드의 경우 카프카 클러스터 전체의 파티션 리미트는 약 20만 개 정도였으나,

리더 선출 과정을 개선한 KRaft 모드에서는 훨씬 더 많은 파티션 생성이 가능합니다.(약 100만개 이상)

![alt text](0f8c7f4f103170fbeaa8de0e74d2457e2262150af100ef0ac9724715473bda04.png)

컨플루언트에서 공개한 KRaft 모드와 주키퍼 모드 간의 속도를 비교한 그림을 살펴보면, 복구 소요시간에서 엄청난 차이를 나타내고 있음을 알 수 있습니다.

이렇게 속도차이가 나는 이유는 KRaft모드에서의 컨트롤러는 메모리 내에 메타데이터 캐시를 유지하고 있으며,

주키퍼와의 의존성도 제거해 내부적으로 메타데이터의 동기화와 관리과정을 효율적으로 개선했기 때문입니다.

또한 액티브 컨트롤러 장애 시 최신 메타데이터가 메모리에 유지되고 있으므로, 메타데이터 복제하는 시간도 줄어들어서 더욱 효율적인 컨트롤러 리더 선출 작업이 일어납니다.



## 마무리

주키퍼가 아닌 kraft를 사용하는 이유를 이렇게 정리 할 수 있겠습니다.

첫째, 성능 향상입니다. KRaft는 파티션 리더 선출 과정을 최적화하여 대량의 파티션을 보다 효율적으로 관리할 수 있습니다. 이는 대규모 데이터 처리 환경에서의 지연 시간을 최소화하고, 시스템의 전반적인 성능을 개선하는 데 기여합니다.

둘째, 운영의 단순화입니다. KRaft는 주키퍼의 의존성을 제거함으로써 설치, 구성, 유지보수가 간소화되었습니다. 이를 통해 관리자는 두 개의 시스템을 동시에 운영하는 부담에서 벗어나 보다 효율적으로 클러스터를 관리할 수 있습니다.

셋째, 확장성입니다. KRaft 모드는 백만 개 이상의 파티션을 지원할 수 있어, 데이터 처리 요구가 증가하는 상황에서도 유연하게 대응할 수 있습니다.

마지막으로, 신뢰성과 안정성입니다. KRaft는 내부적으로 메타데이터를 관리하여 장애 발생 시에도 빠르게 복구할 수 있으며, 최신 메타데이터를 유지하는 덕분에 높은 안정성이 보장됩니다.
